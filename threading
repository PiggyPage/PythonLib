[Python标准库]threading——管理并发操作
    作用：建立在 thread 模块之上，可以更容易地管理多个执行线程。
    Python 版本：1.5.2 及以后版本
    通过使用线程，程序可以在同一个进程空间并发地运行多个操作。threading 模块建立在 thread 的底层特性基础之上，可以更容易地完成线程处理。
Thread 对象
    要使用 Thread，最简单的方法就是用一个目标函数实例化一个 Thread 对象，并调用 start() 让它开始工作。

import threading

def worker():
    """thread worker function"""
    print 'Worker'
    return

threads = []
for i in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()

    输出有 5 行，每一行都是“Worker”。
    如果能够创建一个线程，并向它传递参数告诉它要完成什么工作，这会很有用。任何类型的对象都可以作为参数传递到线程。下面的例子传递了一个数，线程将打印出这个数。

import threading

def worker(num):
    """thread worker function"""
    print 'Worker: %s' % num
    return

threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

    现在整数参数会包含在各线程打印的消息中。
确定当前线程
    使用参数来标识或命名线程很麻烦，也没有必要。每个 Thread 实例都有一个名称，它有一个默认值，可以在创建线程时改变。如果服务器进程由处理不同操作的多个服务线程构成，在这样的服务器进程中，对线程命名就很有用。

import threading
import time

def worker():
    print threading.currentThread().getName(), 'Starting'
    time.sleep(2)
    print threading.currentThread().getName(), 'Exiting'

def my_service():
    print threading.currentThread().getName(), 'Starting'
    time.sleep(3)
    print threading.currentThread().getName(), 'Exiting'

t = threading.Thread(name='my_service', target=my_service)
w = threading.Thread(name='worker', target=worker)
w2 = threading.Thread(target=worker) # use default name

w.start()
w2.start()
t.start()

    调试输出的每一行中包含有当前线程的名称。线程名称列为“Thread-1”的行对应未命名的线程 w2。
    大多数程序并不使用 print 来进行调试。logging 模块支持将线程名嵌入到各个日志消息中（使用格式化代码 %(threadName)s）。通过将线程名包含在日志消息中，这样就能跟踪这些消息的来源。

import logging
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='[%(levelname)s] (%(threadName)-10s) %(message)s',
    )

def worker():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

def my_service():
    logging.debug('Starting')
    time.sleep(3)
    logging.debug('Exiting')

t = threading.Thread(name='my_service', target=my_service)
w = threading.Thread(name='worker', target=worker)
w2 = threading.Thread(target=worker) # use default name

w.start()
w2.start()
t.start()

    logging 也是线程安全的，所以来自不同线程的消息在输出中会有所区分。
守护与非守护线程
    到目前为止，示例程序都隐含地等待所有线程完成工作之后才退出。程序有时会创建一个线程作为守护线程（daemon），这个线程可以一直运行而不阻塞主程序退出。如果一个服务无法用一种容易的方法来中断线程，或者希望线程工作到一半时中止而不损失或破坏数据（如为一个服务监控工具生成“心跳”的线程），对于这些服务，使用守护线程就很有用。要标志一个线程为守护线程，需要调用其 setDaemon() 方法并提供参数 True。默认情况下线程不作为守护线程。

import logging
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
    )

def daemon():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

d = threading.Thread(name='daemon', target=daemon)
d.setDaemon(True)

def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

    输出中没有守护线程的“Exiting”消息，因为在守护线程从其 2 秒的睡眠时间唤醒之前，所有非守护线程（包括主线程）已经退出。
    要等待一个守护线程完成工作，需要使用 join() 方法。

import logging
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
    )

def daemon():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

d = threading.Thread(name='daemon', target=daemon)
d.setDaemon(True)

def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

d.join()
t.join()

    使用 join() 等待守护线程退出，这意味着它将有机会生成它的“Exiting”消息。
    默认情况下，join() 会无限阻塞。还可以传入一个浮点数值，表示等待线程变为不活动所需的时间（秒数）。即使线程在这个时间段内为完成，join() 也会返回。

import logging
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
    )

def daemon():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

d = threading.Thread(name='daemon', target=daemon)
d.setDaemon(True)

def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

d.join(1)
print 'd.isAlive()', d.isAlive()
t.join()

    由于传入的超时时间小于守护线程睡眠的时间，所以 join() 返回之后这个线程仍“存活”。
列举所有线程
    没有必要为所有守护线程维护一个显式句柄来确保它们在退出主进程之前已经完成。enumerate() 会返回活动 Thread 实例的一个列表。这个列表也包括当前线程，由于等待当前线程结束会引入一种死锁情况，所以必须将其跳过。

import logging
import threading
import time
import random

logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
    )

def worker():
    """thread worker function"""
    t = threading.currentThread()
    pause = random.randint(1, 5)
    logging.debug('sleeping %s', pause)
    time.sleep(pause)
    logging.debug('ending')
    return

for i in range(3):
    t = threading.Thread(target=worker)
    t.setDaemon(True)
    t.start()

main_thread = threading.currentThread()
for t in threading.enumerate():
    if t is main_thread:
        continue
    logging.debug('joining %s', t.getName())
    t.join()

    由于工作线程睡眠的时间随机，所以这个线程的输出可能有变化。