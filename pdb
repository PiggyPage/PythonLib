[Python标准库]pdb——交互式调试工具
    作用：Python 的交互式调试工具。
    Python 版本：1.4 及以后版本
    pdb 为 Python 程序实现了一个交互式调试环境。它包括一些特性，可以暂停程序，查看变量值，逐步监视程序执行，使你能了解程序具体做了什么，并查找逻辑中存在的 bug。
启动调试工具
    使用 pdb 的第一步是让解释器在适当时进入调试工具。为此有很多不同的方法，取决于起始条件和所要调试的内容。
    1. 从命令行运行
    使用调试工具的最直接方式是从命令行运行调试工具，提供程序作为输入，使它知道要运行什么。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.count):
			print i
		return

if __name__ == '__main__':
	MyObj(5).go()

    从命令行运行调试工具时，它会加载文件，并在找到的第一条语句处停止执行。在这里，它会在第 7 行类 MyObj 的定义之前停止。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> class MyObj(object):
(Pdb) 

    2. 在解释器中运行
    很多 Python 开发人员开发模块的较早版本时会使用交互式解释器，因为这样他们能反复实验，而不用像创建独立脚本时那样，需要完整地保存/运行/重复周期。要在一个交互式解释器中运行调试工具，可以使用 run() 或 runenval()。

$ python
Python 2.7.6 (default, Jun 22 2015, 18:00:18) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import test
>>> import pdb
>>> pdb.run('test.MyObj(5).go()')
> <string>(1)<module>()
(Pdb) 

    run() 的参数是一个串表达式，可以由 Python 解释器计算。调试工具会进行解析，然后在计算第一个表达式之前暂停执行。这里介绍的调试工具命令可以用来导航和控制执行。
    3. 从程序中运行
    前面的两个例子都是从程序一开始就启动调试工具。对于一个长时间运行的进程，问题可能出现在程序执行较后的时刻，更方便的做法是在程序中使用 set_trace() 启动调试工具。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.count):
			pdb.set_trace()
			print i
		return

if __name__ == '__main__':
	MyObj(5).go()

    示例脚本的第 16 行在执行到该点时触发调试工具。

$ python test.py
> .../test.py(17)go()
-> print i
(Pdb) 

    set_trace() 只是一个 Python 函数，所以可以在程序中任意位置调用。这样就可以根据程序中的条件进入调试工具，包括从一个异常处理程序进入，或者通过一个控制语句的特定分支进入。
    4. 失败后运行
    在程序终止后调试失败称为事后剖析调试（post-mortem debugging）。pdb 通过 pm() 后 post_mortem() 函数支持事后剖析调试。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.num_loops):
			print i
		return

    在这里第 13 行上不正确的属性名触发了一个 AttributeError 异常，导致执行停止，pm() 查找活动 traceback，在调用栈中出现异常的位置启动调试工具。

$ python
Python 2.7.6 (default, Jun 22 2015, 18:00:18) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from test import MyObj
>>> MyObj(5).go()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "test.py", line 13, in go
    for i in range(self.num_loops):
AttributeError: 'MyObj' object has no attribute 'num_loops'
>>> import pdb
>>> pdb.pm()
> .../test.py(13)go()
-> for i in range(self.num_loops):
(Pdb) 

控制调试工具
    调试工具的接口是一个很小的命令语言，允许在调用栈中移动、检查和修改变量的值，以及控制调试工具如何执行程序。这个交互式调试工具使用 readline 来接受命令。输入一个空行会再次重新运行之前的命令，除非是一个 list 操作。
    1. 导航执行栈
    调试工具运行的任何时刻，使用 where（缩写为 w）可以得出正在执行哪一行，以及程序在调用栈的哪个位置。在这里，正在执行模块的 go() 方法中的第 17 行。

$ python test.py
> .../test.py(17)go()
-> print i
(Pdb) where
  .../test.py(21)<module>()
-> MyObj(5).go()
> .../test.py(17)go()
-> print i

    要围绕当前位置添加更多上下文，可以使用 list(l)。

(Pdb) list
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	
 20  	if __name__ == '__main__':
 21  		MyObj(5).go()
[EOF]
(Pdb) 

    默认会列出当前行周围共 11 行（前面 5 行，后面 5 行）。如果使用 list 并提供一个数值参数，则会列出指定行（而不是当前行）周围的 11 行。

(Pdb) list 14
  9  	class MyObj(object):
 10  	
 11  		def __init__(self, num_loops):
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	

    如果 list 接受两个参数，会把它们解释为输出中包含的第一行和最后一行。

(Pdb) list 5, 19
  5  	#
  6  	
  7  	import pdb
  8  	
  9  	class MyObj(object):
 10  	
 11  		def __init__(self, num_loops):
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	

    可以使用 up 和 down 在当前调用栈的帧之间移动。up（缩写为 u）向栈中较早的帧移动。down（缩写为 d）则移向较新的帧。

(Pdb) up
> .../test.py(21)<module>()
-> MyObj(5).go()
(Pdb) down
> .../test.py(17)go()
-> print i

    每次在栈中上移或下移时，调试工具会打印当前位置，格式与 where 生成的格式相同。
    2. 查找栈中的变量
    栈中的各帧维护一组变量，包括所执行函数的局部值和全局状态信息。pdb 提供了多种方法来检查这些变量的内容。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def recursive_fuction(n=5, output='to be printed'):
	if n > 0:
		recursive_fuction(n-1)
	else:
		pdb.set_trace()
		print output
	return

if __name__ == '__main__':
	recursive_fuction()

    args 命令（缩写为 a）会打印当前帧中活动函数的所有参数。这个例子还使用了一个递归函数，以显示由 where 打印一个更深的栈时会得到什么结果。

$ python test.py
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) where
  .../test.py(18)<module>()
-> recursive_fuction()
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) args
n = 0
output = to be printed
(Pdb) up
> .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
(Pdb) args
n = 1
output = to be printed

    p 命令会计算作为参数给定的一个表达式，并打印其结果。也可以使用 Python 的 print 语句，不过要把它传至解释器来执行，而不是在调试工具中作为一个命令运行。

(Pdb) p n
1
(Pdb) print n
1

    类似地，在一个表达式前面加上前缀 ! 就会把它传递到 Python 解释器进行计算。这个特性可以用来执行任意的 Python 语句，包括修改变量。下面这个例子在允许调试工具继续运行程序之前修改了 output 的值。set_trace() 调用后的下一条语句打印出 output 的值，会显示修改后的值。

$ python test.py
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) !output
'to be printed'
(Pdb) !output='changed value'
(Pdb) continue
changed value

    对于更复杂的值，如嵌套数据结构或大型数据结构，要使用 pp 以“完美打印”格式进行打印，下面这个程序从一个文件读取多个文本行。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

with open('lorem.txt', 'rt') as f:
	lines = f.readlines()

pdb.set_trace()

    用 p 打印变量 lines 时，得到的输出很难读，因为它的换行很拙劣。pp 使用 pprint 格式化值以便美观地打印。

$ python test.py
--Return--
> .../test.py(12)<module>()->None
-> pdb.set_trace()
(Pdb) p lines
['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\r\n', 'egestas, enim et consectetuer ullamcorper, lectus ligula rutrum len,\r\n', 'a elementum elit tortor eu quam. Duis tincidunt nisi ut ante. Nulla\r\n', 'facilisi. Sed tristique eros eu libero. Pellentesque vel\r\n', 'arcu. Vivamus purus orci, iaculis ac, suscipit sit amet, pulvinar eu,\r\n', 'lacus. Praesent placerat tortor sed nisl. Nunc blandit diam egestas\r\n', 'dui. Pellentesque habitant morbi tristique senectus et netus et\r\n', 'malesuda fames ac turpis egestas. Aliquam viverra fringilla\r\n', 'leo. Nulla feugiat augue eleifend nulla. Vivamus mauris. Vivamus sed\r\n', 'mauris in nibh placerat egestas. Suspendisse potenti. Mauris\r\n', 'massa. Ut eget velit auctor tortor blandit sollicitudin. Suspendisse\r\n', 'imperdiet justo.']
(Pdb) pp lines
['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\r\n',
 'egestas, enim et consectetuer ullamcorper, lectus ligula rutrum len,\r\n',
 'a elementum elit tortor eu quam. Duis tincidunt nisi ut ante. Nulla\r\n',
 'facilisi. Sed tristique eros eu libero. Pellentesque vel\r\n',
 'arcu. Vivamus purus orci, iaculis ac, suscipit sit amet, pulvinar eu,\r\n',
 'lacus. Praesent placerat tortor sed nisl. Nunc blandit diam egestas\r\n',
 'dui. Pellentesque habitant morbi tristique senectus et netus et\r\n',
 'malesuda fames ac turpis egestas. Aliquam viverra fringilla\r\n',
 'leo. Nulla feugiat augue eleifend nulla. Vivamus mauris. Vivamus sed\r\n',
 'mauris in nibh placerat egestas. Suspendisse potenti. Mauris\r\n',
 'massa. Ut eget velit auctor tortor blandit sollicitudin. Suspendisse\r\n',
 'imperdiet justo.']

    3. 单步执行程序
    除了程序暂停时在调用栈中上下导航外，还可以在进入调试工具那一点之后单步执行程序。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def f(n):
	for i in range(n):
		j = i * n
		print i, j
	return

if __name__ == "__main__":
	pdb.set_trace()
	f(5)

    使用 step 执行当前行，然后在下一个执行点停止——这可能是所调用的函数中的第一条语句，也可能是当前函数的下一行语句。

$ python test.py
> .../test.py(17)<module>()
-> f(5)

    解释器会在 set_trace() 调用处暂停，将控制交给调试工具。第一步会导致执行进入 f()。

(Pdb) step
--Call--
> .../test.py(9)f()
-> def f(n):

    再执行一步会执行到 f() 的第一行，并开始循环。

(Pdb) step
> .../test.py(10)f()
-> for i in range(n):

    执行下一步会移动到循环中的第一行，即定义 j 的代码。

(Pdb) step
> .../test.py(11)f()
-> j = i * n
(Pdb) p i
0

    i 的值为 0，所以再执行一步后，j 的值应当也是 0。

(Pdb) step
> .../test.py(12)f()
-> print i, j
(Pdb) p j
0

    像这样一次执行一步，如果在出现错误那一点之前需要执行很多代码，或者如果需要反复调用相同的函数，就会变得很麻烦。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def calc(i, n):
	j = i * n
	return j

def f(n):
	for i in range(n):
		j = calc(i, n)
		print i, j
	return

if __name__ == "__main__":
	pdb.set_trace()
	f(5)

    在这个例子中，calc() 没有错误，所以在 f() 的循环中每次调用它时如果都单步跟踪，执行时会显示 calc() 的所有代码行，这对有用的输出会造成干扰。

$ python test.py
> .../test.py(21)<module>()
-> f(5)
(Pdb) step
--Call--
> .../test.py(13)f()
-> def f(n):
(Pdb) step
> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) step
--Call--
> .../test.py(9)calc()
-> def calc(i, n):
(Pdb) step
> .../test.py(10)calc()
-> j = i * n
(Pdb) step
> .../test.py(11)calc()
-> return j
(Pdb) step
--Return--
> .../test.py(11)calc()->0
-> return j
(Pdb) step
> .../test.py(16)f()
-> print i, j
(Pdb) step
0 0

    next 命令有些类似 step，不过不会从正在执行的语句进入所调用的函数。实际上，它会用一个操作完成整个函数调用，而直接进入当前函数的下一条语句。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) next
> .../test.py(16)f()
-> print i, j

    until 命令类似于 next，只不过它会继续执行，直至执行到同一个函数中行号大于当前值的一行。例如，这说明，until 可以用于跳过循环末尾。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) next
> .../test.py(16)f()
-> print i, j
(Pdb) until
0 0
1 5
2 10
3 15
4 20
> .../test.py(17)f()
-> return

    运行 until 命令之前，当前行为 16，即循环的最后一行。运行 until 之后，执行位于第 17 行，循环已经结束。
    return 命令也是绕开函数部分的一个捷径。它会继续执行，直至函数将要执行一个 return 语句，然后它会暂停，从而在函数返回前有时间查看返回值。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) return
0 0
1 5
2 10
3 15
4 20
--Return--
> .../test.py(17)f()->None
-> return

断点
