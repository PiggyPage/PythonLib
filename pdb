[Python标准库]pdb——交互式调试工具
    作用：Python 的交互式调试工具。
    Python 版本：1.4 及以后版本
    pdb 为 Python 程序实现了一个交互式调试环境。它包括一些特性，可以暂停程序，查看变量值，逐步监视程序执行，使你能了解程序具体做了什么，并查找逻辑中存在的 bug。
启动调试工具
    使用 pdb 的第一步是让解释器在适当时进入调试工具。为此有很多不同的方法，取决于起始条件和所要调试的内容。
    1. 从命令行运行
    使用调试工具的最直接方式是从命令行运行调试工具，提供程序作为输入，使它知道要运行什么。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.count):
			print i
		return

if __name__ == '__main__':
	MyObj(5).go()

    从命令行运行调试工具时，它会加载文件，并在找到的第一条语句处停止执行。在这里，它会在第 7 行类 MyObj 的定义之前停止。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> class MyObj(object):
(Pdb) 

    2. 在解释器中运行
    很多 Python 开发人员开发模块的较早版本时会使用交互式解释器，因为这样他们能反复实验，而不用像创建独立脚本时那样，需要完整地保存/运行/重复周期。要在一个交互式解释器中运行调试工具，可以使用 run() 或 runenval()。

$ python
Python 2.7.6 (default, Jun 22 2015, 18:00:18) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import test
>>> import pdb
>>> pdb.run('test.MyObj(5).go()')
> <string>(1)<module>()
(Pdb) 

    run() 的参数是一个串表达式，可以由 Python 解释器计算。调试工具会进行解析，然后在计算第一个表达式之前暂停执行。这里介绍的调试工具命令可以用来导航和控制执行。
    3. 从程序中运行
    前面的两个例子都是从程序一开始就启动调试工具。对于一个长时间运行的进程，问题可能出现在程序执行较后的时刻，更方便的做法是在程序中使用 set_trace() 启动调试工具。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.count):
			pdb.set_trace()
			print i
		return

if __name__ == '__main__':
	MyObj(5).go()

    示例脚本的第 16 行在执行到该点时触发调试工具。

$ python test.py
> .../test.py(17)go()
-> print i
(Pdb) 

    set_trace() 只是一个 Python 函数，所以可以在程序中任意位置调用。这样就可以根据程序中的条件进入调试工具，包括从一个异常处理程序进入，或者通过一个控制语句的特定分支进入。
    4. 失败后运行
    在程序终止后调试失败称为事后剖析调试（post-mortem debugging）。pdb 通过 pm() 后 post_mortem() 函数支持事后剖析调试。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

class MyObj(object):

	def __init__(self, num_loops):
		self.count = num_loops

	def go(self):
		for i in range(self.num_loops):
			print i
		return

    在这里第 13 行上不正确的属性名触发了一个 AttributeError 异常，导致执行停止，pm() 查找活动 traceback，在调用栈中出现异常的位置启动调试工具。

$ python
Python 2.7.6 (default, Jun 22 2015, 18:00:18) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from test import MyObj
>>> MyObj(5).go()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "test.py", line 13, in go
    for i in range(self.num_loops):
AttributeError: 'MyObj' object has no attribute 'num_loops'
>>> import pdb
>>> pdb.pm()
> .../test.py(13)go()
-> for i in range(self.num_loops):
(Pdb) 

控制调试工具
    调试工具的接口是一个很小的命令语言，允许在调用栈中移动、检查和修改变量的值，以及控制调试工具如何执行程序。这个交互式调试工具使用 readline 来接受命令。输入一个空行会再次重新运行之前的命令，除非是一个 list 操作。
    1. 导航执行栈
    调试工具运行的任何时刻，使用 where（缩写为 w）可以得出正在执行哪一行，以及程序在调用栈的哪个位置。在这里，正在执行模块的 go() 方法中的第 17 行。

$ python test.py
> .../test.py(17)go()
-> print i
(Pdb) where
  .../test.py(21)<module>()
-> MyObj(5).go()
> .../test.py(17)go()
-> print i

    要围绕当前位置添加更多上下文，可以使用 list(l)。

(Pdb) list
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	
 20  	if __name__ == '__main__':
 21  		MyObj(5).go()
[EOF]
(Pdb) 

    默认会列出当前行周围共 11 行（前面 5 行，后面 5 行）。如果使用 list 并提供一个数值参数，则会列出指定行（而不是当前行）周围的 11 行。

(Pdb) list 14
  9  	class MyObj(object):
 10  	
 11  		def __init__(self, num_loops):
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	

    如果 list 接受两个参数，会把它们解释为输出中包含的第一行和最后一行。

(Pdb) list 5, 19
  5  	#
  6  	
  7  	import pdb
  8  	
  9  	class MyObj(object):
 10  	
 11  		def __init__(self, num_loops):
 12  			self.count = num_loops
 13  	
 14  		def go(self):
 15  			for i in range(self.count):
 16  				pdb.set_trace()
 17  ->				print i
 18  			return
 19  	

    可以使用 up 和 down 在当前调用栈的帧之间移动。up（缩写为 u）向栈中较早的帧移动。down（缩写为 d）则移向较新的帧。

(Pdb) up
> .../test.py(21)<module>()
-> MyObj(5).go()
(Pdb) down
> .../test.py(17)go()
-> print i

    每次在栈中上移或下移时，调试工具会打印当前位置，格式与 where 生成的格式相同。
    2. 查找栈中的变量
    栈中的各帧维护一组变量，包括所执行函数的局部值和全局状态信息。pdb 提供了多种方法来检查这些变量的内容。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def recursive_fuction(n=5, output='to be printed'):
	if n > 0:
		recursive_fuction(n-1)
	else:
		pdb.set_trace()
		print output
	return

if __name__ == '__main__':
	recursive_fuction()

    args 命令（缩写为 a）会打印当前帧中活动函数的所有参数。这个例子还使用了一个递归函数，以显示由 where 打印一个更深的栈时会得到什么结果。

$ python test.py
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) where
  .../test.py(18)<module>()
-> recursive_fuction()
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
  .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) args
n = 0
output = to be printed
(Pdb) up
> .../test.py(11)recursive_fuction()
-> recursive_fuction(n-1)
(Pdb) args
n = 1
output = to be printed

    p 命令会计算作为参数给定的一个表达式，并打印其结果。也可以使用 Python 的 print 语句，不过要把它传至解释器来执行，而不是在调试工具中作为一个命令运行。

(Pdb) p n
1
(Pdb) print n
1

    类似地，在一个表达式前面加上前缀 ! 就会把它传递到 Python 解释器进行计算。这个特性可以用来执行任意的 Python 语句，包括修改变量。下面这个例子在允许调试工具继续运行程序之前修改了 output 的值。set_trace() 调用后的下一条语句打印出 output 的值，会显示修改后的值。

$ python test.py
> .../test.py(14)recursive_fuction()
-> print output
(Pdb) !output
'to be printed'
(Pdb) !output='changed value'
(Pdb) continue
changed value

    对于更复杂的值，如嵌套数据结构或大型数据结构，要使用 pp 以“完美打印”格式进行打印，下面这个程序从一个文件读取多个文本行。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

with open('lorem.txt', 'rt') as f:
	lines = f.readlines()

pdb.set_trace()

    用 p 打印变量 lines 时，得到的输出很难读，因为它的换行很拙劣。pp 使用 pprint 格式化值以便美观地打印。

$ python test.py
--Return--
> .../test.py(12)<module>()->None
-> pdb.set_trace()
(Pdb) p lines
['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\r\n', 'egestas, enim et consectetuer ullamcorper, lectus ligula rutrum len,\r\n', 'a elementum elit tortor eu quam. Duis tincidunt nisi ut ante. Nulla\r\n', 'facilisi. Sed tristique eros eu libero. Pellentesque vel\r\n', 'arcu. Vivamus purus orci, iaculis ac, suscipit sit amet, pulvinar eu,\r\n', 'lacus. Praesent placerat tortor sed nisl. Nunc blandit diam egestas\r\n', 'dui. Pellentesque habitant morbi tristique senectus et netus et\r\n', 'malesuda fames ac turpis egestas. Aliquam viverra fringilla\r\n', 'leo. Nulla feugiat augue eleifend nulla. Vivamus mauris. Vivamus sed\r\n', 'mauris in nibh placerat egestas. Suspendisse potenti. Mauris\r\n', 'massa. Ut eget velit auctor tortor blandit sollicitudin. Suspendisse\r\n', 'imperdiet justo.']
(Pdb) pp lines
['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec\r\n',
 'egestas, enim et consectetuer ullamcorper, lectus ligula rutrum len,\r\n',
 'a elementum elit tortor eu quam. Duis tincidunt nisi ut ante. Nulla\r\n',
 'facilisi. Sed tristique eros eu libero. Pellentesque vel\r\n',
 'arcu. Vivamus purus orci, iaculis ac, suscipit sit amet, pulvinar eu,\r\n',
 'lacus. Praesent placerat tortor sed nisl. Nunc blandit diam egestas\r\n',
 'dui. Pellentesque habitant morbi tristique senectus et netus et\r\n',
 'malesuda fames ac turpis egestas. Aliquam viverra fringilla\r\n',
 'leo. Nulla feugiat augue eleifend nulla. Vivamus mauris. Vivamus sed\r\n',
 'mauris in nibh placerat egestas. Suspendisse potenti. Mauris\r\n',
 'massa. Ut eget velit auctor tortor blandit sollicitudin. Suspendisse\r\n',
 'imperdiet justo.']

    3. 单步执行程序
    除了程序暂停时在调用栈中上下导航外，还可以在进入调试工具那一点之后单步执行程序。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def f(n):
	for i in range(n):
		j = i * n
		print i, j
	return

if __name__ == "__main__":
	pdb.set_trace()
	f(5)

    使用 step 执行当前行，然后在下一个执行点停止——这可能是所调用的函数中的第一条语句，也可能是当前函数的下一行语句。

$ python test.py
> .../test.py(17)<module>()
-> f(5)

    解释器会在 set_trace() 调用处暂停，将控制交给调试工具。第一步会导致执行进入 f()。

(Pdb) step
--Call--
> .../test.py(9)f()
-> def f(n):

    再执行一步会执行到 f() 的第一行，并开始循环。

(Pdb) step
> .../test.py(10)f()
-> for i in range(n):

    执行下一步会移动到循环中的第一行，即定义 j 的代码。

(Pdb) step
> .../test.py(11)f()
-> j = i * n
(Pdb) p i
0

    i 的值为 0，所以再执行一步后，j 的值应当也是 0。

(Pdb) step
> .../test.py(12)f()
-> print i, j
(Pdb) p j
0

    像这样一次执行一步，如果在出现错误那一点之前需要执行很多代码，或者如果需要反复调用相同的函数，就会变得很麻烦。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

import pdb

def calc(i, n):
	j = i * n
	return j

def f(n):
	for i in range(n):
		j = calc(i, n)
		print i, j
	return

if __name__ == "__main__":
	pdb.set_trace()
	f(5)

    在这个例子中，calc() 没有错误，所以在 f() 的循环中每次调用它时如果都单步跟踪，执行时会显示 calc() 的所有代码行，这对有用的输出会造成干扰。

$ python test.py
> .../test.py(21)<module>()
-> f(5)
(Pdb) step
--Call--
> .../test.py(13)f()
-> def f(n):
(Pdb) step
> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) step
--Call--
> .../test.py(9)calc()
-> def calc(i, n):
(Pdb) step
> .../test.py(10)calc()
-> j = i * n
(Pdb) step
> .../test.py(11)calc()
-> return j
(Pdb) step
--Return--
> .../test.py(11)calc()->0
-> return j
(Pdb) step
> .../test.py(16)f()
-> print i, j
(Pdb) step
0 0

    next 命令有些类似 step，不过不会从正在执行的语句进入所调用的函数。实际上，它会用一个操作完成整个函数调用，而直接进入当前函数的下一条语句。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) next
> .../test.py(16)f()
-> print i, j

    until 命令类似于 next，只不过它会继续执行，直至执行到同一个函数中行号大于当前值的一行。例如，这说明，until 可以用于跳过循环末尾。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) step
> .../test.py(15)f()
-> j = calc(i, n)
(Pdb) next
> .../test.py(16)f()
-> print i, j
(Pdb) until
0 0
1 5
2 10
3 15
4 20
> .../test.py(17)f()
-> return

    运行 until 命令之前，当前行为 16，即循环的最后一行。运行 until 之后，执行位于第 17 行，循环已经结束。
    return 命令也是绕开函数部分的一个捷径。它会继续执行，直至函数将要执行一个 return 语句，然后它会暂停，从而在函数返回前有时间查看返回值。

> .../test.py(14)f()
-> for i in range(n):
(Pdb) return
0 0
1 5
2 10
3 15
4 20
--Return--
> .../test.py(17)f()->None
-> return

断点
    随着程序越来越长，即使使用 next 和 until 也会变得很慢，很繁琐。不用手动地单步跟踪程序，一种更好的解决方案是让它正常运行，直至达到某一点，调试工具要在这一点中断执行。set_trace() 可以启动调试工具，不过程序中只有一个要暂停的点时这才适用。更方便的做法是通过调试工具运行程序，但是使用断点（breakpoint）提前告诉调试工具在哪里停止。调试工具会监视程序，到达断点描述的位置时，程序会在执行那一行之前暂停。

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2010 Doug Hellmann. All right reserved.
#

def calc(i, n):
	j = i * n
	print 'j =', j
	if j > 0:
		print 'Positive!'
	return j

def f(n):
	for i in range(n):
		print 'i =', i
		j = calc(i, n)
	return

if __name__ == "__main__":
	f(5)

    break 命令行有很多选项用来设置断点，包括要暂停处理的行号、文件和函数。要在当前文件的一个特定行设置断点，可以使用 break lineno。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break 11
Breakpoint 1 at .../test.py:11
(Pdb) continue
i = 0
j = 0
i = 1
j = 5
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) 

    命令 continue 告诉调试工具继续运行程序，直到到达下一个断点。在这里，它会运行完 f() 中 for 循环的第一次迭代，第二次迭代期间在 calc() 中停止。
    可以指定函数名而不是一个行号，把断点设置到一个函数的第一行。下面这个例子显示了为 calc() 函数增加一个断点会发生什么。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break calc
Breakpoint 1 at .../test.py:7
(Pdb) continue
i = 0
> .../test.py(8)calc()
-> j = i * n
(Pdb) where
  /usr/lib/python2.7/bdb.py(400)run()
-> exec cmd in globals, locals
  <string>(1)<module>()
  .../test.py(21)<module>()
-> f(5)
  .../test.py(17)f()
-> j = calc(i, n)
> .../test.py(8)calc()
-> j = i * n
(Pdb) 

    要在另一个文件中指定一个断点，可以在行或函数参数前加一个文件名前缀。

#!/usr/bin/env python
# encoding: utf-8

from test import f

f(5)

    在这里，开始主程序 test_remote.py 之后，为 test.py 的第 11 行设置了一个断点。

$ python -m pdb test_remote.py 
> .../test_remote.py(4)<module>()
-> from test import f
(Pdb) break test.py:11
Breakpoint 1 at .../test.py:11
(Pdb) continue
i = 0
j = 0
i = 1
j = 5
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) 

    文件名可以是源文件的完整路径，也可以是相对于 sys.path 上某个文件的相对路径。
    要列出当前设置的断点，可以使用 break 而不带任何参数。输出包括文件和各个断点的行号，以及多少次遇到这个断点的有关信息。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break 11
Breakpoint 1 at .../test.py:11
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:11
(Pdb) continue
i = 0
j = 0
i = 1
j = 5
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) continue
Positive!
i = 2
j = 10
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:11
	breakpoint already hit 2 times
(Pdb) 

    1. 管理断点
    增加一个新断点时，会为它指定一个数值标识符。这些 id 号用于交互式地启用、禁用和删除断点。用 disable 关闭一个断点时，会告诉调试工具到达该行时不要停止。这个断点仍会记住，但是会将其忽略。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break calc
Breakpoint 1 at .../test.py:7
(Pdb) break 11
Breakpoint 2 at .../test.py:11
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:7
2   breakpoint   keep yes   at .../test.py:11
(Pdb) disable 1
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep no    at .../test.py:7
2   breakpoint   keep yes   at .../test.py:11
(Pdb) continue
i = 0
j = 0
i = 1
j = 5
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) 

    下一个调试会话在程序中设置两个断点，然后禁用其中一个。程序会一直运行，直至遇到留下的那个断点，然后在执行继续之前用 enable 把另一个断点打开。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break calc
Breakpoint 1 at .../test.py:7
(Pdb) break 16
Breakpoint 2 at .../test.py:16
(Pdb) disable 1
(Pdb) continue
> .../test.py(16)f()
-> print 'i =', i
(Pdb) list
 11  			print 'Positive!'
 12  		return j
 13  	
 14  	def f(n):
 15  		for i in range(n):
 16 B->			print 'i =', i
 17  			j = calc(i, n)
 18  		return
 19  	
 20  	if __name__ == "__main__":
 21  		f(5)
(Pdb) continue
i = 0
j = 0
> .../test.py(16)f()
-> print 'i =', i
(Pdb) list
 11  			print 'Positive!'
 12  		return j
 13  	
 14  	def f(n):
 15  		for i in range(n):
 16 B->			print 'i =', i
 17  			j = calc(i, n)
 18  		return
 19  	
 20  	if __name__ == "__main__":
 21  		f(5)
(Pdb) p i
1
(Pdb) enable 1
(Pdb) continue
i = 1
> .../test.py(8)calc()
-> j = i * n
(Pdb) list
  3  	#
  4  	# Copyright (c) 2010 Doug Hellmann. All right reserved.
  5  	#
  6  	
  7 B	def calc(i, n):
  8  ->		j = i * n
  9  		print 'j =', j
 10  		if j > 0:
 11  			print 'Positive!'
 12  		return j
 13  	
(Pdb) 

    list 的输出中带 B 前缀的行显示了程序中哪里设置了断点（第 7 行和第 16 行）。可以使用 clear 完全删除一个断点。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break calc
Breakpoint 1 at .../test.py:7
(Pdb) break 11
Breakpoint 2 at .../test.py:11
(Pdb) break 16
Breakpoint 3 at .../test.py:16
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:7
2   breakpoint   keep yes   at .../test.py:11
3   breakpoint   keep yes   at .../test.py:16
(Pdb) clear 2
Deleted breakpoint 2
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:7
3   breakpoint   keep yes   at .../test.py:16
(Pdb) 

    其他断点仍保留原来的标识符，不会重新编号。
    2. 临时断点
    程序第一次执行到临时断点时会将它自动清除。通过使用临时断点，可以很快到达程序流中的特定位置，这与常规断点一样，只是它会立即清除。不过，如果这部分程序反复运行，临时断点不会干扰后续执行。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) tbreak 11
Breakpoint 1 at .../test.py:11
(Pdb) continue
i = 0
j = 0
i = 1
j = 5
Deleted breakpoint 1
> .../test.py(11)calc()
-> print 'Positive!'
(Pdb) break
(Pdb) continue
Positive!
i = 2
j = 10
Positive!
i = 3
j = 15
Positive!
i = 4
j = 20
Positive!
The program finished and will be restarted
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) 

    程序第一次到达第 11 行时，会将断点删除，在程序完成之前不会再停止执行。
    3. 条件断点
    可以对断点应用一些规则，仅当条件满足时执行才停止。相对于手动地启用和禁用断点，使用条件断点可以对调试工具如何暂停程序提供更精细的控制。可以用两种方式设置条件断点。第一种是使用 break 指定设置断点时的条件。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break 9, j>0
Breakpoint 1 at .../test.py:9
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:9
	stop only if j>0
(Pdb) continue
i = 0
j = 0
i = 1
> .../test.py(9)calc()
-> print 'j =', j
(Pdb) 

    条件参数必须是一个表达式，要使用定义断点的栈帧中可见的值。如果表达式计算为 true，则在断点处停止执行。
    还可以使用 condition 命令对一个现有的断点应用条件。参数是断点 id 和表达式。

$ python -m pdb test.py
> .../test.py(7)<module>()
-> def calc(i, n):
(Pdb) break 9
Breakpoint 1 at .../test.py:9
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:9
(Pdb) condition 1 j > 0
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../test.py:9
	stop only if j > 0
(Pdb) 

    4. 忽略断点
