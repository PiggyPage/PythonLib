[Python标准库]sqlite3——嵌入式关系数据库
    作用：实现一个嵌入式关系数据库，并提供 SQL 支持。
    Python 版本：2.5 及以后版本
    sqlite3 模块为 SQLite 提供了一个 DB-API 2.0 兼容接口，SQLite 是一个进程中关系数据库。SQLite 设计为嵌入在应用中，而不是像 MySQL、PostgreSQL 或 Oracle 使用一个单独的数据库服务器程序。SQLite 的速度很快、经过了严格的测试，而且很灵活，所以非常适合为一些应用建立原型和生产部署。
创建数据库
    SQLite 数据库作为一个文件存储在文件系统中。这个库管理对文件的访问，包括加锁来防止多个书写器使用它时造成破坏。数据库在第一次访问文件时创建，不过应用要负责管理数据库中的数据库表定义，即模式（schema）。
    下面这个例子在用 connect() 打开数据库文件之前先查找这个文件，以便了解何时为新数据库创建模式。

import os
import sqlite3

db_filename = 'todo.db'

db_is_new = not os.path.exists(db_filename)

conn = sqlite3.connect(db_filename)

if db_is_new:
    print 'Need to create schema'
else:
    print 'Database exists, assume schema dose, too.'

conn.close()

    将这个脚本运行两次，可以看到，如果文件尚不存在则会创建空文件。
    创建新的数据库文件后，下一步是创建模式来定义数据库中的表。这一节余下的例子使用的数据库模式与管理任务的表相同。数据库模式的详细信息见下表：
                      “project” 表
    --------------------------------------------------
          列      |  类型  |           描述
    --------------------------------------------------
      name        |  text  |  项目名
    --------------------------------------------------
      description |  text  |  详细的项目描述
    --------------------------------------------------
      deadline    |  date  |  整个项目的预定结束日期
    --------------------------------------------------

                          “task” 表
    ----------------------------------------------------------------
          列      |   类型   |                  描述
    ----------------------------------------------------------------
      id          |  number  |  唯一任务标识
    ----------------------------------------------------------------
      priority    |  integer |  优先级数值：值越小越重要
    ----------------------------------------------------------------
      details     |  text    |  完备的任务详细描述
    ----------------------------------------------------------------
      status      |  text    |  任务状态[new/pending/done/canceled]
    ----------------------------------------------------------------
      deadline    |  date    |  这个任务的预定结束日期
    ----------------------------------------------------------------
      completed_on|  date    |  任务何时完成
    ----------------------------------------------------------------
      project     |  text    |  这个任务对应的项目名
    ----------------------------------------------------------------
    以下是创建这些表的数据定义语言（data definition language, DDL）语句。

-- Schema for to-do application examples.

-- Projects are high-level activities made up of tasks
create table project (
    name        text primary key,
    description text,
    deadline    date
);

-- Task are steps that can be taken to complete a project
create table task (
    id           integer primary key autoincrement not null,
    priority     integer default 1,
    details      text,
    status       text,
    deadline     date,
    completed_on date,
    project      text not null references project(name)
);
    可以用 Connection 的 executescript() 方法来运行创建模式的 DDL 指令。

import os
import sqlite3

db_filename = 'todo.db'
schema_filename = 'todo_schema.sql'

db_is_new = not os.path.exists(db_filename)

with sqlite3.connect(db_filename) as conn:
    if db_is_new:
        print 'Creating schema'
        with open(schema_filename, 'rt') as f:
            schema = f.read()
        conn.executescript(schema)

        print 'Inserting initial data'

        conn.executescript(
            """
            insert into project (name, description, deadline)
            values ('pymotw', 'Python Module of the Week', '2010-11-01');
            insert into task (details, status, deadline, project)
            values ('write about select', 'done', '2010-10-03', 'pymotw');
            insert into task (details, status, deadline, project)
            values ('write about random', 'waiting', '2010-10-10', 'pymotw');
            insert into task (details, status, deadline, project)
            values ('write about sqlite3', 'active', '2010-10-17', 'pymotw');
            """
            )
    else:
        print 'Database exists, assume schema does, too.'

    创建这些数据表之后，用一些插入语句创建一个示例项目和相关的任务。可以用 sqlite3 命令行程序检查数据库的内容。
获取数据
    要从一个 Python 程序中获取 task 表中保存的值，可以从数据库连接创建一个 cursor。游标（cursor）会生成一个一致的数据视图，这也是与类似 SQLite 的事务型数据库系统交互的主要方式。

import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute(
        """
        select id, priority, details, status, deadline from task
        where project = 'pymotw'
        """
        )

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-20s [%-8s] (%s)' % \
              (task_id, priority, details, status, deadline)

    查询过程包括两步。首先，用游标的 execute() 方法运行查询，告诉数据库引擎要收集哪些数据。然后，使用 fetchall() 获取结果。返回值是一个元组序列，元组中包含查询 select 子句中所包括的列的值。
    可以用 fetchone() 一次获取一个结果，也可以用 fetchmany() 获取固定大小的批量结果。

import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute(
        """
        select name, description, deadline from project
        where name = 'pymotw'
        """
        )
    name, description, deadline = cursor.fetchone()
    print 'Project details for %s (%s) due %s' % \
              (description, name, deadline)

    cursor.execute(
        """
        select id, priority, details, status, deadline from task
        where project = 'pymotw' order by deadline
        """
        )

    print '\nNext 5 tasks:'
    for row in cursor.fetchmany(5):
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-25s [%-8s] (%s)' % \
              (task_id, priority, details, status, deadline)

    传入 fetchmany() 的值是要返回的最大元素数。如果没有提供足够的元素，返回的序列大小将小于这个最大值。
查询元数据
    DB-API 2.0 规范指出：调用 execute() 之后，cursor 应当设置其 description 属性，来保存将由 fetch 方法返回的数据的有关信息。API 规范指出这个描述值是一个元组序列，各元组包含列名、类型、显示大小、内部大小、精度、范围和一个指示是否接受 null 值的标志。

import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute(
        """
        select * from task where project = 'pymotw'
        """
        )

    print 'Task table has these columns:'
    for coinfo in cursor.description:
        print coinfo

    由于 sqlite3 对插入到数据库的数据没有类型或大小约束，所以只填入列名值。
行对象
    默认情况下，获取方法从数据库作为“行”返回的值是元组。调用者负责了解查询中列的顺序，并从元组中抽取单个的值。查询的值个数增加时，或者处理数据的代码分布在一个库的不同位置时，通常更容易的做法是处理一个对象，并使用其列名来访问值。这样一来，编辑查询时，元组内容的个数和顺序可以随时间改变，另外依赖于查询结果的代码也不太可能出问题。
    Connection 对象有一个 row_factory 属性，允许调用代码控制所创建对象的类型来表示查询结果集中的各行。sqlite3 还包括一个 Row 类，这个类将用作一个行工厂。可以通过 Row 实例使用列索引或名来访问列值。

import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    # Change the row factory to use Row
    conn.row_factory = sqlite3.Row
    
    cursor = conn.cursor()

    cursor.execute(
        """
        select name, description, deadline from project
        where name = 'pymotw'
        """
        )
    name, description, deadline = cursor.fetchone()
    
    print 'Project details for %s (%s) due %s' % (
        description, name, deadline)
    
    cursor.execute(
        """
        select id, priority, details, status, deadline from task
        where project = 'pymotw' order by deadline
        """
        )

    print '\nNext 5 tasks:'
    for row in cursor.fetchmany(5):
        print '%2d {%d} %-25s [%-8s] (%s)' % (
            row['id'], row['priority'], row['details'],
            row['status'], row['deadline'],
            )

    这个版本的例子重写为使用 Row 实例而不是元组。打印 project 表中的行时仍然通过位置来访问列值，不过打印任务的 print 语句使用了关键字查找，所以任务查询中列顺序的该表并不会有任何影响。
查询中使用变量
    如果查询定义为字面量字符串嵌入到程序中，使用这种查询很不灵活。例如，向数据库添加另一个项目时，显示前 5 个任务的查询就应当更新，以处理其中某一个项目。要想增加灵活性，一种方法是建立一个 SQL 语句，通过在 Python 中结合相应的值来得到所需的查询。不过，以这种方式构造查询串很危险，应当尽量避免。如果未能对查询中可变部分的特殊字符正确转义，可能会导致 SQL 解析错误，或者更糟糕的是，还有可能导致一个安全漏洞，称为 SQL 注入攻击（SQL-injection attack），这使得入侵者可以在数据库中执行任意的 SQL 语句。
    要在查询中使用动态值，正确的方法是利用随 SQL 指令一起传入 execute() 的宿主变量（host variable）。SQL 语句执行时，语句中的占位符值会替换为宿主变量的值。通过使用宿主变量，而不是解析之前在 SQL 语句中插入任意的值，这样可以避免注入攻击，因为不可信的值没有机会影响 SQL 语句的解析。SQLite 支持两种形式带占位符的查询，分别是位置参数和命名参数。
    1. 位置参数
    问号（?）指示一个位置参数，将作为元组的一个成员传至 execute()。

import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()
    query = """select id, priority, details, status, deadline from task
            where project = ?
            """

    cursor.execute(query, (project_name,))

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-20s [%-8s] (%s)' % (
            task_id, priority, details, status, deadline)

    命令行参数会作为位置参数安全地传至查询，所以恶意数据不可能破坏数据库。
    2. 命名参数
    对于包含大量参数的更为复杂的查询，或者如果查询中某些参数会重复多次，则可以使用命名参数。命令参数前面有一个冒号作为前缀（例如，:param_name）。

import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()
    query = """select id, priority, details, status, deadline from task
            where project = :project_name
            order by deadline, priority
            """

    cursor.execute(query, {'project_name':project_name})

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-20s [%-8s] (%s)' % (
            task_id, priority, details, status, deadline)

    位置或命名参数都不需要加引号或转义，因为查询解析器会对它们做特殊处理。
    查询参数可以在 select（选择）、insert（插入）和 update（更新）语句中使用。查询中字面量能够出现的位置都可以放置查询参数。

import sqlite3
import sys

db_filename = 'todo.db'
id = int(sys.argv[1])
status = sys.argv[2]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()
    query = "update task set status = :status where id = :id"
    cursor.execute(query, {'status':status, 'id':id})

    这个 update 语句使用了两个命名参数。id 值用于查找要修改的行，status 值则要写入数据表。
批量加载
    要对一个很大的数据集应用相同的 SQL 指令，可以使用 executemany()。这对于加载数据很有用，因为这样可以避免在 Python 中循环处理输入，而是让底层库对循环应用一些优化。下面这个示例程序使用 csv 模块从一个逗号分隔值文件读取任务列表，并将其加载到数据库。

import csv
import sqlite3
import sys

db_filename = 'todo.db'
data_filename = sys.argv[1]

SQL = """
      insert into task (details, priority, status, deadline, project)
      values (:details, :priority, 'active', :deadline, :project)
      """

with open(data_filename, 'rt') as csv_file:
    csv_reader = csv.DictReader(csv_file)

    with sqlite3.connect(db_filename) as conn:
        cursor = conn.cursor()
        cursor.executemany(SQL, csv_reader)

    示例数据文件 tasks.csv 包含以下数据:
    deadline,project,priority,details
    2010-10-02,pymotw,2,"finish reviewing markup"
    2010-10-03,pymotw,2,"revise chapter intros"
    2010-10-03,pymotw,3,"subtitle"
定义新列类型
    SQLite 对整数、浮点数和文本列提供了内置支持。sqlite3 会自动将这些类型的数据从 Python 的表示转换为可在数据库中存储的一个值，还可以根据需要从数据库中存储的值转换回 Python 的表示。整数值由数据库加载为 int 或 long 变量，这取决于值的大小。文本将作为 unicode 保存和获取（除非改变了 Connection 的 text_factory）。
    尽管 SQLite 在内部只支持几种数据类型，不过 sqlite3 包括了一些便利工具，可以定义定制类型，允许 Python 应用在列中存储任意类型的数据。除了那些得到默认支持的类型外，还可以在数据库连接中使用 detect_types 标志启用其他类型。如果定义表时列使用所要求的类型来声明，可以使用 PARSE_DECLTYPES。

import sqlite3
import sys

db_filename = 'todo.db'

sql = "select id, details, deadline from task"

def show_deadline(conn):
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute(sql)
    row = cursor.fetchone()
    for col in ['id', 'details', 'deadline']:
        print '  %-8s  %-30r %s' % (col, row[col], type(row[col]))
    return

print 'Without type detection:'
with sqlite3.connect(db_filename) as conn:
    show_deadline(conn)

print '\nWith type detection'
with sqlite3.connect(db_filename,
                     detect_types=sqlite3.PARSE_DECLTYPES,
                     ) as conn:
    show_deadline(conn)

    sqlite3 为日期和时间戳列提供了转换器，它使用 datetime 模块的 date 和 datetime 表示 Python 中的值。这两个与日期有关的转换器会在打开类型检测时自动启用。
    定义一个新类型需要注册两个函数。适配器（adapter）取 Python 对象作为输入，返回一个可以存储在数据库中的字节串。转换器（converter）从数据库接收串，返回一个 Python 对象。要使用 register_adapter() 定义适配器函数，使用 register_converter() 定义转换器函数。

import sqlite3
try:
    import cPickle as pickle
except:
    import pickle

db_filename = 'todo.db'

sql = "select id, details, deadline from task"

def adapter_func(obj):
    """Convert from in-memory to storage representation."""
    print 'adapter_func(%s)\n' % obj
    return pickle.dumps(obj)

def converter_func(data):
    """Convert from storage to in-memory representation."""
    print 'converter_func(%r)\n' % data
    return pickle.loads(data)

class MyObj(object):
    def __init__(self, arg):
        self.arg = arg
    def __str__(self):
        return 'MyObj(%r)' % self.arg

# Register the functions for manipulating the type.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Create some objects to save.  Use a list of tuples so
# the sequence can be passed directly to executemany().
to_save = [ (MyObj('this is a value to save'),),
            (MyObj(42),),
            ]

with sqlite3.connect(db_filename,
                     detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Create a table with column of type "MyObj"
    conn.execute("""
    create table if not exists obj (
        id    integer primary key autoincrement not null,
        data  MyObj
    )
    """)
    cursor = conn.cursor()

    # Insert the objects into the database
    cursor.executemany("insert into obj (data) values (?)", to_save)

# Query the database for the objects just saved
cursor.execute("select id, data from obj")
for obj_id, obj in cursor.fetchall():
    print 'Retrieved', obj_id, obj, type(obj)
    print

    这个例子使用 pickle 将一个对象保存为可以存储在数据库中的串，这对于存储任意的对象很有用，不过这种技术不支持按对象属性查询。正真的对象关系映射器（object-relational mapper，如 SQLAlchemy）可以将属性值存储在单独的列中，这对于大量数据更为有用。
确定列类型
    查询返回的值的类型信息有两个来源。可以用原表声明来识别一个实际列的类型，这在前面已经看到。另外还可以在查询自身的 select 子句中包含类型指示符，采用以下形式：as "name[type]"。

import sqlite3
try:
    import cPickle as pickle
except:
    import pickle

db_filename = 'todo.db'

sql = "select id, details, deadline from task"

def adapter_func(obj):
    """Convert from in-memory to storage representation."""
    print 'adapter_func(%s)\n' % obj
    return pickle.dumps(obj)

def converter_func(data):
    """Convert from storage to in-memory representation."""
    print 'converter_func(%r)\n' % data
    return pickle.loads(data)

class MyObj(object):
    def __init__(self, arg):
        self.arg = arg
    def __str__(self):
        return 'MyObj(%r)' % self.arg

# Register the functions for manipulating the type.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Create some objects to save.  Use a list of tuples so
# the sequence can be passed directly to executemany().
to_save = [ (MyObj('this is a value to save'),),
            (MyObj(42),),
            ]

with sqlite3.connect(db_filename,
                     detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Create a table with column of type "MyObj"
    conn.execute("""
    create table if not exists obj2 (
        id    integer primary key autoincrement not null,
        data  MyObj
    )
    """)
    cursor = conn.cursor()

    # Insert the objects into the database
    cursor.executemany("insert into obj2 (data) values (?)", to_save)

# Query the database for the objects just saved
cursor.execute('select id, data as "pickle [MyObj]" from obj2')
for obj_id, obj in cursor.fetchall():
    print 'Retrieved', obj_id, obj, type(obj)
    print

    如果类型是查询的一部分而不属于原表定义，则要使用 detect_types 标志 PARSE_COLNAMES。